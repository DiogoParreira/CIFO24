import numpy as np
from Operators.fitness import fitness

class HillClimbing():
    def __init__(self, initial_board, board):
        """
        Constructor for the hill climbing class
        :param initial_board: an NxN numpy array representing the initial state of the board, where N has to be a perfect square. 0s represent empty cells
        :param board: an NxN numpy array representing the current state of the board, without 0s
        """
        self.initial_board = initial_board.copy()
        self.board = board.copy()
        self.swappable_positions = list(zip(*np.where(self.initial_board == 0)))
        self.fitness = fitness(self.board)

    def get_neighbours(self, number_of_neighbours : int = 1, swap_number : int = 1):
        """
        Function to get the neighbours of the individual
        :param number_of_neighbours: an int representing the number of neighbours to generate
        :param swap_number: an int representing the number of swaps to make in the board
        """
        # Neighbours will be generated by swapping numbers in the board
        neighbours = []
        for _ in range(number_of_neighbours):
            neighbour = self.board.copy()
            np.random.shuffle(self.swappable_positions)
            for i in range(swap_number):
                # Randomly select two swappeable positions 
                neighbour[self.swappable_positions[2*i]], neighbour[self.swappable_positions[2*i+1]] = neighbour[self.swappable_positions[2*i+1]], neighbour[self.swappable_positions[2*i]]
            neighbour_individual = HillClimbing(self.initial_board, neighbour)
            neighbours.append(neighbour_individual)
        return neighbours
    

    def run(self, max_iterations : int = 1000, num_neighbours : int = 1, swap_number : int = 1, plateau_threshold : int = 100, verbose : int = 0):
        """
        Function to run the hill climbing algorithm
        :param max_iterations: an int representing the maximum number of iterations
        :param number_of_neighbours: an int representing the number of neighbours to generate
        :param swap_number: an int representing the number of swaps to make in the board
        :param plateau_threshold: an int representing the number of iterations without improvement to consider the algorithm has reached a plateau
        :param verbose: an int representing if the algorithm should print messages, 0 for no messages, 1 for critical messages and 2 for finish messages, and 3 for all messages
        """
        threshold = 0
        for i in range(max_iterations):
            neighbours = self.get_neighbours(num_neighbours, swap_number)
            best_neighbour = min(neighbours, key=lambda x: x.fitness)

            if best_neighbour.fitness <= self.fitness:
                threshold = 0
                self.fitness = best_neighbour.fitness
                self.board = best_neighbour.board.copy()
                print(f"Iter {i} : Found a better board with fitness {self.fitness}") if verbose >= 3 else None
            
            else: 
                threshold += 1
                if threshold >= plateau_threshold:
                    print(f"Reached a plateau in {i} iterations") if verbose >= 1 else None
                    break
                
            if self.fitness == 0:
                print(f"Found a solution in {i} iterations") if verbose >= 2 else None
                break
